{
    "version": "https://jsonfeed.org/version/1",
    "title": "Blog",
    "description": "algorithm && study notes",
    "home_page_url": "http://www.lucky233.buzz",
    "items": [
        {
            "id": "http://www.lucky233.buzz/2023/08/14/algorithm/%E6%9C%80%E7%9F%AD%E8%B7%AF/",
            "url": "http://www.lucky233.buzz/2023/08/14/algorithm/%E6%9C%80%E7%9F%AD%E8%B7%AF/",
            "title": "",
            "date_published": "2023-08-14T15:18:08.615Z",
            "content_html": "<h3 id=\"bellman-ford\"><a class=\"anchor\" href=\"#bellman-ford\">#</a> Bellman-Ford</h3>\n<ul>\n<li>\n<p>每条边都会存在一个边权的图，路径长度指的是路径上边的权值和</p>\n</li>\n<li>\n<p>我们要找出两点之间长度最短（总权值和最小）的路径，最短路的长度就是两个点之间的距离</p>\n</li>\n<li>\n<p>对于无相图的一条边 (u -&gt; v)，可以看作有乡土中两条边 (u -&gt; v) 和 (u -&gt; v) 的结合，我们可以 i 用这种方式将无相图转化成有向图，因此我们接下来介绍的都是有向图上的最短路算法</p>\n</li>\n<li>\n<p>图记作</p>\n<ul>\n<li>G = &lt;V, E&gt; 代表我们要处理的简单有向图</li>\n<li>n = |V|, m = |E | 代表顶点数和边数</li>\n<li>l (u, v) 代表 u 到 v 的边长度 (边权)</li>\n<li>S 表示起点，T 表示终点 (如果有的话)</li>\n<li>dist (u) 代表我们当前求出的 S 到 u 的最短路径的长度，后面简称为 u 的距离</li>\n</ul>\n</li>\n<li>\n<p>对于所有边权都大于等于 0 的图，任意两个顶点之间的最短路，显然不会经过重复的顶点或者边。也就是说任意一条最短路经过的顶点数不会超过 n 个，边不会超过 n-1 条</p>\n</li>\n<li>\n<p>对于有边权为负的图，可能图中存在负环，此时途径负环的最短路没有意义（注意：不是说存在负环的图中就不存在最短路）</p>\n</li>\n<li>\n<p>Bellman-Ford 的核心思想是<strong>松弛操作</strong>，即对于边 (u, v)，用 dist (u) 和 l (u, v) 的和尝试更新 dist (v)<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>d</mi><mi>i</mi><mi>s</mi><mi>t</mi><mo stretchy=\"false\">(</mo><mi>v</mi><mo stretchy=\"false\">)</mo><mo>=</mo><mi>m</mi><mi>i</mi><mi>n</mi><mo stretchy=\"false\">(</mo><mi>d</mi><mi>i</mi><mi>s</mi><mi>t</mi><mo stretchy=\"false\">(</mo><mi>v</mi><mo stretchy=\"false\">)</mo><mo separator=\"true\">,</mo><mi>d</mi><mi>i</mi><mi>s</mi><mi>t</mi><mo stretchy=\"false\">(</mo><mi>u</mi><mo stretchy=\"false\">)</mo><mo>+</mo><mi>l</mi><mo stretchy=\"false\">(</mo><mi>u</mi><mo separator=\"true\">,</mo><mi>v</mi><mo stretchy=\"false\">)</mo><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">dist(v) = min(dist(v), dist(u) + l(u, v))</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">d</span><span class=\"mord mathnormal\">i</span><span class=\"mord mathnormal\">s</span><span class=\"mord mathnormal\">t</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">v</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">m</span><span class=\"mord mathnormal\">i</span><span class=\"mord mathnormal\">n</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">d</span><span class=\"mord mathnormal\">i</span><span class=\"mord mathnormal\">s</span><span class=\"mord mathnormal\">t</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">v</span><span class=\"mclose\">)</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathnormal\">d</span><span class=\"mord mathnormal\">i</span><span class=\"mord mathnormal\">s</span><span class=\"mord mathnormal\">t</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">u</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.01968em;\">l</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">u</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">v</span><span class=\"mclose\">)</span><span class=\"mclose\">)</span></span></span></span> 不断队图上每一条边进行松弛操作</p>\n</li>\n<li>\n<p>会进行多次迭代，没进行一次迭代，就对图上所有的边进行一次松弛操作，当一次迭代中的 dist 发生改变时，算法停止</p>\n</li>\n<li>\n<p><img src=\"https://s2.loli.net/2023/08/14/mWuD7eAJa4qpn1Q.png\" alt=\"屏幕截图 2023-07-22 180218.png\" /></p>\n</li>\n<li>\n<p><img src=\"https://s2.loli.net/2023/08/14/inKzqUYBkPIXmcQ.png\" alt=\"屏幕截图 2023-07-22 181310.png\" /></p>\n</li>\n<li>\n<p>没有任何更新的时候算法结束</p>\n</li>\n<li>\n<p>最短路存在的情况下，由于一次迭代会使最短路的边数至少加一，而 S 到每个顶点的最短路经过的边数最多为 n-1, 因此整个算法最多会进行 n-1 轮迭代，每一轮迭代的复杂度为 O (m)(每边枚举到一次)，所以总的算法时间复杂度为 O (nm)</p>\n</li>\n<li>\n<p>当从 S 点出发能达到一个负环，就会进行 n 轮以上的迭代</p>\n</li>\n<li>\n<p>能否用 O (nm) 的复杂度来检测图上是否存在负环       可以，从某个起点出发设置成 0，迭代 n 轮看看还能不能更新，如果可以就是存在负环</p>\n</li>\n</ul>\n<h4 id=\"代码\"><a class=\"anchor\" href=\"#代码\">#</a> 代码</h4>\n<pre><code class=\"language-c++\">struct Edge &#123;\n    int x, y, v;\n    // x 起点， y 终点， v边权\n&#125;edge[M + 1];\nint n, m, dist[N + 1], pre[N + 1];\n// n 多少个点， m多少个边， dist 离起点的距离  pre最短路长度的上一个点\n\nint shortestpath(int s, int t) &#123;\n    memset(dist, 127, sizeof(dist)); // 无穷大\n    memset(pre, 127, sizeof(pre));\n    dist[s] = 0;\n    for (; ; ) &#123;\n        bool ok = false; // 看看这个位置有没有点更新\n        for (int i = 1; i &lt;= m; i++) &#123;\n            int x = edge[i].x, y = edge[i].y, v = edge[i].v;\n            // 潜在最短路存在\n            if (dist[x] &lt; 1 &lt;&lt; 30) &#123;\n                // 进行松弛操作\n                if (dist[x] + v &lt; dist[y]) &#123;\n                    dist[y] = dist[x] + v;\n                    pre[y] = x;\n                    ok = true;\n                &#125;\n            &#125;\n        &#125;\n        // 如果一次都更新不了，就break \n        if (!ok)\n            break;\n    &#125;\n    if (dist[t] &lt; 1 &lt;&lt; 30)&#123;\n    \tretrun dist[t];\n    &#125; else &#123;\n        return -1;\n    &#125;\n&#125;\n</code></pre>\n<h4 id=\"bellman-ford优化方法\"><a class=\"anchor\" href=\"#bellman-ford优化方法\">#</a> Bellman-Ford 优化方法</h4>\n<ul>\n<li>队列优化 (SPFA): 每一次迭代的时候，只有在上一次迭代中被更新了距离的点，才有可能更新其它节点，因此，在每一次迭代的时候，我们将更新过的距离的顶点加入一个队列（如果顶点已经在队列里则不加），在一下次迭代时只需要变量队列中的顶点连出去的边即可</li>\n<li>SPFA 在最坏情况下都会被卡刀 O (mn) 的时间复杂度</li>\n</ul>\n<pre><code class=\"language-c++\">vector&lt;pair&lt;int, int&gt;&gt;edge[N];\nint q[N], dist[N], pre[N]\nbool b[N]\ninline int shortestpath(int s, int t) &#123;\n    memset(dist, 127, sizeof(dist));\n    memset(pre, 0, sizeof(pre));\n    dist[s] = 0;\n    b[s] = true;\n    int front = 1, rear = 1;\n    q[rear] = s;\n    while (front &lt;= rear) &#123;\n        int x = q[front];\n        ++front;\n        b[x] = false;\n        for (auto i : edge[x]) &#123;\n            if (dist[x] + i.second &lt; dist[i.first]) &#123;\n                dist[i.firtst] = dist[x] + i.second;\n                if (!b[i.first]) &#123;\n                    q[++rear] = i.first;\n                    b[i.first] = true;\n                &#125;\n            &#125;\n        &#125;\n    &#125;\n    if (dist[t] &lt; 1 &lt;&lt; 30) &#123;\n        return dist[t];\n    &#125; else &#123;\n\t\t\n    &#125;\n&#125;\n\nedge[x].push_back(make_pair(y, v));  存图\n</code></pre>\n<h3 id=\"dijkstra\"><a class=\"anchor\" href=\"#dijkstra\">#</a> Dijkstra</h3>\n<ul>\n<li>\n<p>Dijkstra 算法常用于求<strong>无负权</strong>边图中的最短路，在优化后有比 Bellman-Ford 算法优秀很多的时间复杂度</p>\n</li>\n<li>\n<p><img src=\"https://s2.loli.net/2023/08/14/aK6uGfzHD4RBrWO.png\" alt=\"屏幕截图 2023-08-09 185421.png\" /></p>\n</li>\n<li>\n<p><img src=\"https://s2.loli.net/2023/08/14/tOIoV3QPphjg9FK.png\" alt=\"屏幕截图 2023-08-09 212934.png\" /></p>\n</li>\n<li>\n<p>在每一轮中，将里起点最近的 (dist 最小，不能是无穷大) 的还不在 C 中的顶点加入 C，并且用这个点连出去的边通过松弛操作尝试更新其他的 dist</p>\n</li>\n<li>\n<p>没有新的点加入 C 了，算法结束</p>\n</li>\n</ul>\n<h4 id=\"代码实现\"><a class=\"anchor\" href=\"#代码实现\">#</a> 代码实现</h4>\n<ul>\n<li>将 C 设置为空，将 S 的距离设置为 0，其余顶点的距离设置为无穷大</li>\n<li>在每一轮中，将离起点最近的（dist 最小，不能是无穷大）的还不 C 中的顶点加入 C，并且用这个点连出去的边通过松弛操作尝试更新其它的 dist</li>\n<li>当 T（如果 T 存在的话）或者没有新的点加入 C 时，算法结束</li>\n<li>时间复杂度<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo>+</mo><mi>m</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(n^2 + m)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.064108em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathnormal\">n</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">m</span><span class=\"mclose\">)</span></span></span></span></li>\n</ul>\n<pre><code class=\"language-c++\">struct Node &#123;\n    int y, v;\n    Node(int _y, int_v) &#123;y = _y; v = _v&#125;;// 构造函数\n&#125;;\n\nvector&lt;Node&gt; edge[N + 1];\nint n, m, dist[N + 1];\nbool b[N + 1];\n\nint Dijkstra(int s, int t) &#123;\n    memset(b, false, sizeof(b));\n    memset(dist, 127, sizeof(dist));\n    dist[s] = 0;\n    for (; ;) &#123;\n        int x = -1;\n        for (int i = 1; i &lt;= n; ++i) &#123;\n            if (!b[i] &amp;&amp; dist[i] &lt;&lt; 1 &lt;&lt; 30) \n                if (x == -1 || dist[i] &lt; dist[x]) \n                    x = i;\n        if (x == t || x == -1)\n            break;\n        b[x] = true;\n        for (auto i : edge[x])\n            dist[i.y] = min(dist[i.y], dist[x] + i.v)\n        &#125;\n    &#125;\n    retrun dist[t];\n&#125;\n\n\n</code></pre>\n<h4 id=\"堆优化\"><a class=\"anchor\" href=\"#堆优化\">#</a> 堆优化</h4>\n<ul>\n<li>堆优化 (优先队列)</li>\n<li>我们采用一个堆来维护 dist 数组，算法时间复杂度可以提升至<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mo stretchy=\"false\">(</mo><mi>n</mi><mo>+</mo><mi>m</mi><mo stretchy=\"false\">)</mo><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O((n + m)logn)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">m</span><span class=\"mclose\">)</span><span class=\"mord mathnormal\" style=\"margin-right:0.01968em;\">l</span><span class=\"mord mathnormal\">o</span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">g</span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span></span></span></span>   n 非常大， m 很小，效果更好</li>\n<li>这里我们用 set</li>\n</ul>\n<pre><code class=\"language-c++\">struct Node &#123;\n    int y, v;\n    Node(int _y, int _v) &#123;y = _y; v = _v;&#125;;// 构造函数\n&#125;;\n\nset&lt; pair&lt;int, int&gt; &gt; q; // set 里面时平衡树维护\n// pair 比较的时候优先比较第一个，然后比较第二个\nvector&lt;Node&gt; edge[N + 1];\nint n, m, dist[N + 1];\n\nint Dijkstra(int s, int t) &#123;\n    memset(dist, 127, sizeof(dist));\n    dist[s] = 0;\n    q.clear();\n    for (int i = 1; i &lt;= n; ++i) &#123;\n        q.insert(make_pair(dist[i], i));\n    &#125;\n    while(!q.empty()) &#123;\n        int x = q.begin() -&gt; second;\n        // q 里面放的是还没有加到 dist里面的元素，set的头永远是最小的\n        q.erase(q.begin());\n        if (x == t || dist[x] &gt; 1 &lt;&lt; 30) &#123;\n            break;\n        &#125;\n        for (auto i : edge[x]) &#123;\n            if (dist[x] + i.v &lt; dist[i.y]) &#123;\n                q.erase(make_pair(dist[i.y], i.y));\n                dist[i.y] = dist[x] + i.v;\n                q.insert(make_pair(dist[i.y], i.y));\n            &#125;\n        &#125;\n    &#125;\n    \n    return dist[t];\n&#125;\n</code></pre>\n<h3 id=\"floyd\"><a class=\"anchor\" href=\"#floyd\">#</a> Floyd</h3>\n<p>前面两种最短路算法，求的都是从一个起始点开始的最短路，如果我们相求图中所有顶点之间的最短路，就需要枚举每个点做为起点，这样子非常低效</p>\n<p>Floyd 算法处理用邻接矩阵来存储的有向图非常方便</p>\n<ul>\n<li>Floyd 算法代码</li>\n</ul>\n<pre><code class=\"language-c++\">memset(f, 127, sizeof(f));\nf[0][i][j] = a[i][j];\n// a 数组为存储有向图边权的矩阵，若存在从i到j的边，a[i][j]记录的是这些边的边权的最小值，若不存在从i到j的边，a[i][j]为无穷大；对于所有的i，a[i][j] = 0；\n\nfor (int k = 1; k &lt;= n; ++k) &#123;\n    for (int i = 1; i &lt;= n; ++i) &#123;\n        for (int j = 1; j &lt;= n; ++j) &#123;\n            f[k][i][j] = min(f[k - 1][i][j], f[k - 1][i][k] + f[k - 1][k][j]);\n        &#125;\n    &#125;\n&#125;\n</code></pre>\n<ul>\n<li>\n<p><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>f</mi><mo stretchy=\"false\">[</mo><mi>k</mi><mo stretchy=\"false\">]</mo><mo stretchy=\"false\">[</mo><mi>i</mi><mo stretchy=\"false\">]</mo><mo stretchy=\"false\">[</mo><mi>j</mi><mo stretchy=\"false\">]</mo></mrow><annotation encoding=\"application/x-tex\">f[k][i][j]</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mopen\">[</span><span class=\"mord mathnormal\" style=\"margin-right:0.03148em;\">k</span><span class=\"mclose\">]</span><span class=\"mopen\">[</span><span class=\"mord mathnormal\">i</span><span class=\"mclose\">]</span><span class=\"mopen\">[</span><span class=\"mord mathnormal\" style=\"margin-right:0.05724em;\">j</span><span class=\"mclose\">]</span></span></span></span> 表示从 i 到 j，中间可以经过 1~k 号顶点的最短路径的长度</p>\n</li>\n<li>\n<p>从 i 到 j，中间可以经过 1~K 号顶点的路径分为两种：一种是没经过 k 号顶点的，另一种是经过 k 号顶点的</p>\n</li>\n<li>\n<p><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>f</mi><mo stretchy=\"false\">[</mo><mi>n</mi><mo stretchy=\"false\">]</mo><mo stretchy=\"false\">[</mo><mi>u</mi><mo stretchy=\"false\">]</mo><mo stretchy=\"false\">[</mo><mi>v</mi><mo stretchy=\"false\">]</mo></mrow><annotation encoding=\"application/x-tex\">f[n][u][v]</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mopen\">[</span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">]</span><span class=\"mopen\">[</span><span class=\"mord mathnormal\">u</span><span class=\"mclose\">]</span><span class=\"mopen\">[</span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">v</span><span class=\"mclose\">]</span></span></span></span> 即为从 u 到 v 的最短路径的长度，若等于无穷大则表示不存在从 u 到 v 的路径</p>\n</li>\n<li>\n<p>Floyd 算法的时间复杂度为<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><msup><mi>n</mi><mn>3</mn></msup><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(n^3)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.064108em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathnormal\">n</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">3</span></span></span></span></span></span></span></span><span class=\"mclose\">)</span></span></span></span></p>\n</li>\n</ul>\n<pre><code class=\"language-c++\">memset(f, 127, sizeof(v));\nv[i][j] = a[i][j];\n\nfor (int k = 1; k &lt;= n; ++k) &#123;\n    for (int i = 1; i &lt;= n; ++i) &#123;\n        for (int j = 1; j &lt;= n; ++j) &#123;\n            if (v[i][k] &lt; 1 &lt;&lt; 30 &amp;&amp; v[k][j] &lt; 1 &lt;&lt; 30) &#123;\n                v[i][j] = min(v[i][j], v[i][k] + v[k][j]);\n            &#125;\n        &#125;\n    &#125;\n&#125;\n\n</code></pre>\n<ul>\n<li>现在我们想把<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>v</mi><mo stretchy=\"false\">[</mo><mi>i</mi><mo stretchy=\"false\">]</mo><mo stretchy=\"false\">[</mo><mi>j</mi><mo stretchy=\"false\">]</mo></mrow><annotation encoding=\"application/x-tex\">v[i][j]</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">v</span><span class=\"mopen\">[</span><span class=\"mord mathnormal\">i</span><span class=\"mclose\">]</span><span class=\"mopen\">[</span><span class=\"mord mathnormal\" style=\"margin-right:0.05724em;\">j</span><span class=\"mclose\">]</span></span></span></span> 从<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>f</mi><mo stretchy=\"false\">[</mo><mi>k</mi><mo>−</mo><mn>1</mn><mo stretchy=\"false\">]</mo><mo stretchy=\"false\">[</mo><mi>i</mi><mo stretchy=\"false\">]</mo><mo stretchy=\"false\">[</mo><mi>j</mi><mo stretchy=\"false\">]</mo></mrow><annotation encoding=\"application/x-tex\">f[k - 1][i][j]</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mopen\">[</span><span class=\"mord mathnormal\" style=\"margin-right:0.03148em;\">k</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">1</span><span class=\"mclose\">]</span><span class=\"mopen\">[</span><span class=\"mord mathnormal\">i</span><span class=\"mclose\">]</span><span class=\"mopen\">[</span><span class=\"mord mathnormal\" style=\"margin-right:0.05724em;\">j</span><span class=\"mclose\">]</span></span></span></span> 更新成<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>f</mi><mo stretchy=\"false\">[</mo><mi>k</mi><mo stretchy=\"false\">]</mo><mo stretchy=\"false\">[</mo><mi>i</mi><mo stretchy=\"false\">]</mo><mo stretchy=\"false\">[</mo><mi>j</mi><mo stretchy=\"false\">]</mo></mrow><annotation encoding=\"application/x-tex\">f[k][i][j]</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mopen\">[</span><span class=\"mord mathnormal\" style=\"margin-right:0.03148em;\">k</span><span class=\"mclose\">]</span><span class=\"mopen\">[</span><span class=\"mord mathnormal\">i</span><span class=\"mclose\">]</span><span class=\"mopen\">[</span><span class=\"mord mathnormal\" style=\"margin-right:0.05724em;\">j</span><span class=\"mclose\">]</span></span></span></span></li>\n<li>用于计算<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>f</mi><mo stretchy=\"false\">[</mo><mi>k</mi><mo stretchy=\"false\">]</mo><mo stretchy=\"false\">[</mo><mi>i</mi><mo stretchy=\"false\">]</mo><mo stretchy=\"false\">[</mo><mi>j</mi><mo stretchy=\"false\">]</mo></mrow><annotation encoding=\"application/x-tex\">f[k][i][j]</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mopen\">[</span><span class=\"mord mathnormal\" style=\"margin-right:0.03148em;\">k</span><span class=\"mclose\">]</span><span class=\"mopen\">[</span><span class=\"mord mathnormal\">i</span><span class=\"mclose\">]</span><span class=\"mopen\">[</span><span class=\"mord mathnormal\" style=\"margin-right:0.05724em;\">j</span><span class=\"mclose\">]</span></span></span></span> 的两个部分中，从 i 到 j 中间可以经过 1~k-1 号顶点的最短距离路径长度<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>f</mi><mo stretchy=\"false\">[</mo><mi>k</mi><mo>−</mo><mn>1</mn><mo stretchy=\"false\">]</mo><mo stretchy=\"false\">[</mo><mi>i</mi><mo stretchy=\"false\">]</mo><mo stretchy=\"false\">[</mo><mi>j</mi><mo stretchy=\"false\">]</mo></mrow><annotation encoding=\"application/x-tex\">f[k-1][i][j]</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mopen\">[</span><span class=\"mord mathnormal\" style=\"margin-right:0.03148em;\">k</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">1</span><span class=\"mclose\">]</span><span class=\"mopen\">[</span><span class=\"mord mathnormal\">i</span><span class=\"mclose\">]</span><span class=\"mopen\">[</span><span class=\"mord mathnormal\" style=\"margin-right:0.05724em;\">j</span><span class=\"mclose\">]</span></span></span></span> 现在就存在<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>v</mi><mo stretchy=\"false\">[</mo><mi>i</mi><mo stretchy=\"false\">]</mo><mo stretchy=\"false\">[</mo><mi>j</mi><mo stretchy=\"false\">]</mo></mrow><annotation encoding=\"application/x-tex\">v[i][j]</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">v</span><span class=\"mopen\">[</span><span class=\"mord mathnormal\">i</span><span class=\"mclose\">]</span><span class=\"mopen\">[</span><span class=\"mord mathnormal\" style=\"margin-right:0.05724em;\">j</span><span class=\"mclose\">]</span></span></span></span> 中，另一部分<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>f</mi><mo stretchy=\"false\">[</mo><mi>k</mi><mo>−</mo><mn>1</mn><mo stretchy=\"false\">]</mo><mo stretchy=\"false\">[</mo><mi>i</mi><mo stretchy=\"false\">]</mo><mo stretchy=\"false\">[</mo><mi>k</mi><mo stretchy=\"false\">]</mo><mo>+</mo><mi>f</mi><mo stretchy=\"false\">[</mo><mi>k</mi><mo>−</mo><mn>1</mn><mo stretchy=\"false\">]</mo><mo stretchy=\"false\">[</mo><mi>k</mi><mo stretchy=\"false\">]</mo><mo stretchy=\"false\">[</mo><mi>j</mi><mo stretchy=\"false\">]</mo></mrow><annotation encoding=\"application/x-tex\">f[k-1][i][k] + f[k - 1][k][j]</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mopen\">[</span><span class=\"mord mathnormal\" style=\"margin-right:0.03148em;\">k</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">1</span><span class=\"mclose\">]</span><span class=\"mopen\">[</span><span class=\"mord mathnormal\">i</span><span class=\"mclose\">]</span><span class=\"mopen\">[</span><span class=\"mord mathnormal\" style=\"margin-right:0.03148em;\">k</span><span class=\"mclose\">]</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mopen\">[</span><span class=\"mord mathnormal\" style=\"margin-right:0.03148em;\">k</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">1</span><span class=\"mclose\">]</span><span class=\"mopen\">[</span><span class=\"mord mathnormal\" style=\"margin-right:0.03148em;\">k</span><span class=\"mclose\">]</span><span class=\"mopen\">[</span><span class=\"mord mathnormal\" style=\"margin-right:0.05724em;\">j</span><span class=\"mclose\">]</span></span></span></span> 的值在这一轮更新中不会发生改变 (<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>f</mi><mo stretchy=\"false\">[</mo><mi>k</mi><mo>−</mo><mn>1</mn><mo stretchy=\"false\">]</mo><mo stretchy=\"false\">[</mo><mi>i</mi><mo stretchy=\"false\">]</mo><mo stretchy=\"false\">[</mo><mi>k</mi><mo stretchy=\"false\">]</mo><mo>=</mo><mi>f</mi><mo stretchy=\"false\">[</mo><mi>k</mi><mo stretchy=\"false\">]</mo><mo stretchy=\"false\">[</mo><mi>i</mi><mo stretchy=\"false\">]</mo><mo stretchy=\"false\">[</mo><mi>k</mi><mo stretchy=\"false\">]</mo><mo separator=\"true\">,</mo><mi>f</mi><mo stretchy=\"false\">[</mo><mi>k</mi><mo>−</mo><mn>1</mn><mo stretchy=\"false\">]</mo><mo stretchy=\"false\">[</mo><mi>k</mi><mo stretchy=\"false\">]</mo><mo stretchy=\"false\">[</mo><mi>j</mi><mo stretchy=\"false\">]</mo><mo>=</mo><mi>f</mi><mo stretchy=\"false\">[</mo><mi>k</mi><mo stretchy=\"false\">]</mo><mo stretchy=\"false\">[</mo><mi>k</mi><mo stretchy=\"false\">]</mo><mo stretchy=\"false\">[</mo><mi>j</mi><mo stretchy=\"false\">]</mo></mrow><annotation encoding=\"application/x-tex\">f[k-1][i][k] = f[k][i][k],f[k-1][k][j] = f[k][k][j]</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mopen\">[</span><span class=\"mord mathnormal\" style=\"margin-right:0.03148em;\">k</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">1</span><span class=\"mclose\">]</span><span class=\"mopen\">[</span><span class=\"mord mathnormal\">i</span><span class=\"mclose\">]</span><span class=\"mopen\">[</span><span class=\"mord mathnormal\" style=\"margin-right:0.03148em;\">k</span><span class=\"mclose\">]</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mopen\">[</span><span class=\"mord mathnormal\" style=\"margin-right:0.03148em;\">k</span><span class=\"mclose\">]</span><span class=\"mopen\">[</span><span class=\"mord mathnormal\">i</span><span class=\"mclose\">]</span><span class=\"mopen\">[</span><span class=\"mord mathnormal\" style=\"margin-right:0.03148em;\">k</span><span class=\"mclose\">]</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mopen\">[</span><span class=\"mord mathnormal\" style=\"margin-right:0.03148em;\">k</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">1</span><span class=\"mclose\">]</span><span class=\"mopen\">[</span><span class=\"mord mathnormal\" style=\"margin-right:0.03148em;\">k</span><span class=\"mclose\">]</span><span class=\"mopen\">[</span><span class=\"mord mathnormal\" style=\"margin-right:0.05724em;\">j</span><span class=\"mclose\">]</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mopen\">[</span><span class=\"mord mathnormal\" style=\"margin-right:0.03148em;\">k</span><span class=\"mclose\">]</span><span class=\"mopen\">[</span><span class=\"mord mathnormal\" style=\"margin-right:0.03148em;\">k</span><span class=\"mclose\">]</span><span class=\"mopen\">[</span><span class=\"mord mathnormal\" style=\"margin-right:0.05724em;\">j</span><span class=\"mclose\">]</span></span></span></span>)，所以可以使用<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>v</mi><mo stretchy=\"false\">[</mo><mi>i</mi><mo stretchy=\"false\">]</mo><mo stretchy=\"false\">[</mo><mi>k</mi><mo stretchy=\"false\">]</mo><mo>+</mo><mi>v</mi><mo stretchy=\"false\">[</mo><mi>k</mi><mo stretchy=\"false\">]</mo><mo stretchy=\"false\">[</mo><mi>j</mi><mo stretchy=\"false\">]</mo></mrow><annotation encoding=\"application/x-tex\">v[i][k] + v[k][j]</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">v</span><span class=\"mopen\">[</span><span class=\"mord mathnormal\">i</span><span class=\"mclose\">]</span><span class=\"mopen\">[</span><span class=\"mord mathnormal\" style=\"margin-right:0.03148em;\">k</span><span class=\"mclose\">]</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">v</span><span class=\"mopen\">[</span><span class=\"mord mathnormal\" style=\"margin-right:0.03148em;\">k</span><span class=\"mclose\">]</span><span class=\"mopen\">[</span><span class=\"mord mathnormal\" style=\"margin-right:0.05724em;\">j</span><span class=\"mclose\">]</span></span></span></span> 代替而不用担心更新的顺序</li>\n</ul>\n",
            "tags": []
        },
        {
            "id": "http://www.lucky233.buzz/2023/08/14/%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/",
            "url": "http://www.lucky233.buzz/2023/08/14/%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/",
            "title": "第一篇博客",
            "date_published": "2023-08-14T12:54:00.000Z",
            "content_html": "<p>Hello World!</p>\n<h2 id=\"第一章\"><a class=\"anchor\" href=\"#第一章\">#</a> 第一章</h2>\n<h2 id=\"第二章\"><a class=\"anchor\" href=\"#第二章\">#</a> 第二章</h2>\n<h2 id=\"第三章\"><a class=\"anchor\" href=\"#第三章\">#</a> 第三章</h2>\n<h2 id=\"参考文献\"><a class=\"anchor\" href=\"#参考文献\">#</a> 参考文献</h2>\n",
            "tags": []
        },
        {
            "id": "http://www.lucky233.buzz/2023/08/14/hello-world/",
            "url": "http://www.lucky233.buzz/2023/08/14/hello-world/",
            "title": "Hello World",
            "date_published": "2023-08-14T12:50:06.450Z",
            "content_html": "<p>Welcome to <a href=\"https://hexo.io/\">Hexo</a>! This is your very first post. Check <a href=\"https://hexo.io/docs/\">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href=\"https://hexo.io/docs/troubleshooting.html\">troubleshooting</a> or you can ask me on <a href=\"https://github.com/hexojs/hexo/issues\">GitHub</a>.</p>\n<h2 id=\"quick-start\"><a class=\"anchor\" href=\"#quick-start\">#</a> Quick Start</h2>\n<h3 id=\"create-a-new-post\"><a class=\"anchor\" href=\"#create-a-new-post\">#</a> Create a new post</h3>\n<figure class=\"highlight bash\"><figcaption data-lang=\"bash\"><span>h</span></figcaption><table><tr><td data-num=\"1\"></td><td><pre>$ hexo new <span class=\"token string\">\"My New Post\"</span></pre></td></tr></table></figure><p>More info: <a href=\"https://hexo.io/docs/writing.html\">Writing</a></p>\n<h3 id=\"run-server\"><a class=\"anchor\" href=\"#run-server\">#</a> Run server</h3>\n<figure class=\"highlight bash\"><figcaption data-lang=\"bash\"><span>h</span></figcaption><table><tr><td data-num=\"1\"></td><td><pre>$ hexo server</pre></td></tr></table></figure><p>More info: <a href=\"https://hexo.io/docs/server.html\">Server</a></p>\n<h3 id=\"generate-static-files\"><a class=\"anchor\" href=\"#generate-static-files\">#</a> Generate static files</h3>\n<figure class=\"highlight bash\"><figcaption data-lang=\"bash\"><span>h</span></figcaption><table><tr><td data-num=\"1\"></td><td><pre>$ hexo generate</pre></td></tr></table></figure><p>More info: <a href=\"https://hexo.io/docs/generating.html\">Generating</a></p>\n<h3 id=\"deploy-to-remote-sites\"><a class=\"anchor\" href=\"#deploy-to-remote-sites\">#</a> Deploy to remote sites</h3>\n<figure class=\"highlight bash\"><figcaption data-lang=\"bash\"><span>h</span></figcaption><table><tr><td data-num=\"1\"></td><td><pre>$ hexo deploy</pre></td></tr></table></figure><p>More info: <a href=\"https://hexo.io/docs/one-command-deployment.html\">Deployment</a></p>\n",
            "tags": []
        }
    ]
}